import colorsys
import glob
import os
import random

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image, ImageOps
import torch
from torch import nn
from torch.utils.data import Dataset, DataLoader

from main import generate_input_images, FOLDER_ROOT, FOLDER_TRAIN_INPUTS, FOLDER_TRAIN_OUTPUTS, OUTPUT_SIZE


# Dataset size.
NUMBER_SAMPLES = 100
# Minimum and maximum values of parameters to be varied.
LOAD_RANGE = (0, 100000)
ANGLE_RANGE = (0, 360)
LENGTH_RANGE = (0.1, 4)
HEIGHT_RANGE = (0.1, 1)
# The two angle values at which there should be peaks in the bimodal probability distribution used to generate angle values.
ANGLE_PEAKS = (0, 180)
# Standard deviation for probability distribution used to generate angle values.
ANGLE_STD = 45

# Name of text file to contain samples.
FILENAME_TEXT = 'cantilever_samples.txt'

# Return randomly generated sample values.
def generate_samples():
    load_samples = np.random.uniform(LOAD_RANGE[0], LOAD_RANGE[1], NUMBER_SAMPLES)
    angle_samples = np.array([
        random.choice([
            np.random.normal(loc=ANGLE_PEAKS[0], scale=ANGLE_STD),
            np.random.normal(loc=ANGLE_PEAKS[1], scale=ANGLE_STD),
            ]) for _ in range(NUMBER_SAMPLES)
            ])
    length_samples = np.random.uniform(LENGTH_RANGE[0], LENGTH_RANGE[1], NUMBER_SAMPLES)
    height_samples = np.random.uniform(HEIGHT_RANGE[0], HEIGHT_RANGE[1], NUMBER_SAMPLES)
    # Fix out-of-bounds angle samples.
    angle_samples = np.mod(angle_samples, ANGLE_RANGE[1])
    # Round all samples to a fixed number of decimal places.
    load_samples = np.round(load_samples, 2)
    angle_samples = np.round(angle_samples, 2)
    length_samples = np.round(length_samples, 2)
    height_samples = np.round(height_samples, 2)

    # # Plot angle samples.
    # plt.figure()
    # plt.hist(angle_samples, bins=round(ANGLE_RANGE[1]-ANGLE_RANGE[0])*2, color='#0095ff')
    # plt.xlabel('Angle (degrees)')
    # plt.xticks(range(ANGLE_RANGE[0], ANGLE_RANGE[1]+1, round(ANGLE_RANGE[1]/4)))
    # plt.title('Histogram of Angle Samples')
    # plt.show()
    return load_samples, angle_samples, length_samples, height_samples

# Write the specified sample values to a text file.
def write_samples(samples):
    load_samples, angle_samples, length_samples, height_samples = samples
    # Determine the x and y components of the load for easier entry in FEA.
    load_components = []
    for load, angle in zip(load_samples, angle_samples):
        angle *= (np.pi / 180)
        load_components.append((
            np.cos(angle) * load,
            np.sin(angle) * load,
            ))
    # Write samples to text file.
    text = [
        f'Load: {load:>10},  X load: {load_x:>10},  Y load: {load_y:>10},  Angle: {angle:>10},  Length: {length:>5},  Height: {height:>5}\n'
        for load, (load_x, load_y), angle, length, height in zip(load_samples, load_components, angle_samples, length_samples, height_samples)
        ]
    with open(os.path.join(FOLDER_ROOT, FILENAME_TEXT), 'w') as file:
        file.writelines(text)
    print(f'Wrote samples in {FILENAME_TEXT}.')

# Return the sample values found in the text file previously generated.
def read_samples():
    angle_samples = []
    filename = os.path.join(FOLDER_ROOT, FILENAME_TEXT)
    try:
        with open(filename, 'r') as file:
            for string in file.readlines():
                *_, angle = [int(float(string.split(':')[1])) for string in string.split(',')]
                angle_samples.append(angle)
        print(f'Found samples in {filename}.')
    except FileNotFoundError:
        print(f'"{filename}" not found.')
    return angle_samples

# Crop and resize the stress contour images.
def crop_output_images():
    # LEFT, TOP = 209, 108
    # SIZE = (616, 155)
    filenames = glob.glob(os.path.join(FOLDER_TRAIN_OUTPUTS, '*.png'))
    for filename in filenames:
        with Image.open(filename) as image:
            # if image.size[0] > SIZE[0] and image.size[1] > SIZE[1]:
            #     image = image.crop((LEFT, TOP, LEFT+SIZE[0]-1, TOP+SIZE[1]-1))
            image_copy = image.convert('L')
            area = ImageOps.invert(image_copy).getbbox()
            image = image.crop(area)
            image = image.resize(OUTPUT_SIZE)
            image.save(filename)

# Try to read sample values from the text file if it already exists. If not, generate the samples.
# samples = read_samples()
if True: #not samples:
    samples = generate_samples()
    write_samples(samples)
# generate_input_images(samples, FOLDER_TRAIN_INPUTS)

# Crop and resize stress contour images generated by FEA. This only needs to run the first time the images are added to the folder.
# crop_output_images()